/*! Tooltipster 4.0.0rc39 */

/**
 * http://iamceege.github.io/tooltipster/
 * 
 * A rockin' custom tooltip jQuery plugin
 * Developed by Caleb Jacob and Louis Ameline under the MIT license http://opensource.org/licenses/MIT
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

;(function($) {
	
	var globalCore = function() {},
		defaults = {
			animation: 'fade',
			animationDuration: 350,
			content: null,
			contentAsHTML: false,
			contentCloning: false,
			debug: true,
			delay: 300,
			functionInit: null,
			functionBefore: null,
			functionReady: null,
			functionAfter: null,
			functionFormat: null,
			interactive: false,
			multiple: false,
			// must be 'body' for now, or an element positioned at (0, 0)
			// in the document, typically like very top views of an app.
			parent: 'body',
			plugins: ['sideTip'],
			repositionOnScroll: false,
			restoration: 'none',
			selfDestruction: true,
			theme: [],
			timer: 0,
			touchDevices: true,
			trackerInterval: 500,
			trackOrigin: false,
			trackTooltip: false,
			trigger: 'hover',
			triggerClose: {
				click: false,
				mouseleave: false,
				originClick: false,
				scroll: false
			},
			triggerOpen: {
				hover: false,
				click: false
			},
			updateAnimation: 'rotate',
			zIndex: 9999999
		},
		$emitterGlobal = $({}),
		instancesLatest = [],
		// collects plugins in their bare object form
		plugins = {},
		// don't edit manually, it will be updated by grunt after the manifest
		semVer = '4.0.0';
	
	
	// global methods
	globalCore.prototype = {
		/**
		 * A function to proxy the methods of an object onto another
		 *
		 * @param {object} methods List of methods to proxy
		 * @param {object} obj The original object that holds the methods
		 * @param {object} proxy The object that will get new methods
		 * @param {string} ref A plugin name for the console log message
		 */
		_bridge: function(methods, obj, proxy, ref) {
			
			$.each(methods, function(methodName, fn) {
				
				if (methodName.charAt(0) != '_') {
					
					// if the method does not exist yet
					if (!proxy[methodName]) {
						
						proxy[methodName] = function() {
							fn.apply(obj, Array.prototype.slice.apply(arguments));
							return proxy;
						};
					}
					else if (defaults.debug) {
						
						console.log('The '+ methodName +' method of the '+ ref
							+' plugin conflicts with another plugin or native methods');
					}
				}
			});
		},
		/**
		 * Returns instances of all tooltips in the page or an a given element
		 *
		 * @param {string|HTML object collection} selector optional Use this
		 * parameter to restrict the set of objects that will be inspected
		 * for the retrieval of instances. By default, all instances in the
		 * page are returned.
		 * @return {array}
		 */
		instances: function(selector) {
			
			var instances = [],
				sel = selector || '.tooltipstered';
			
			$(sel).each(function() {
				
				var $this = $(this),
					ns = $this.data('tooltipster-ns');
				
				if (ns) {
					
					$.each(ns, function(i, namespace) {
						instances.push($this.data(namespace));
					});
				}
			});
			
			return instances;
		},
		/**
		 * Returns the Tooltipster objects generated by the last initializing call
		 *
		 * @return {array}
		 */
		instancesLatest: function() {
			return instancesLatest;
		},
		off: function() {
			$emitterGlobal.off.apply($emitterGlobal, Array.prototype.slice.apply(arguments));
			return this;
		},
		on: function() {
			$emitterGlobal.on.apply($emitterGlobal, Array.prototype.slice.apply(arguments));
			return this;
		},
		one: function() {
			$emitterGlobal.one.apply($emitterGlobal, Array.prototype.slice.apply(arguments));
			return this;
		},
		/**
		 * Returns all HTML elements which have one or more tooltips
		 *
		 * @param {string} selector optional Use this to restrict the results
		 * to the descendants of an element
		 */
		origins: function(selector) {
			
			var sel = selector ?
			selector +' ' :
				'';
			
			return $(sel +'.tooltipstered').toArray();
		},
		/**
		 * Returns (getter) or adds (setter) a plugin
		 * 
		 * @param {string|object} plugin Provide a string (in the full form
		 * "namespace.name") to use as as getter, an object to use as a setter
		 * @return {object|self}
		 */
		plugin: function(plugin) {
			
			var self = this;
			
			// getter
			if (typeof plugin == 'string') {
				
				var pluginName = plugin,
					p = null;
				
				// if the namespace is provided, it's easy to search
				if (pluginName.indexOf('.') > 0) {
					p = plugins[pluginName];
				}
				// otherwise, return the first name that matches
				else {
					$.each(plugins, function(i, plugin) {
						
						if (plugin.name.substring(plugin.name.length - pluginName.length - 1) == '.'+ pluginName) {
							p = plugin;
							return false;
						}
					});
				}
				
				return p;
			}
			// setter
			else {
				
				// force namespaces
				if (plugin.name.indexOf('.') < 0) {
					throw new Error('Plugins must be namespaced');
				}
				
				plugins[plugin.name] = plugin;
				
				// if the plugin has global features
				if (plugin.global) {
					
					// instantiate at global level
					var fn = function(){};
					fn.prototype = plugin.global;
					
					var p = new fn();
					
					self[plugin.name] = p;
					
					if (p._init) {
						p._init(self);
					}
					
					// proxy public methods on the core to allow new global methods
					self._bridge(plugin.global, p, self, plugin.name);
				}
				
				return this;
			}
		},
		/**
		 * Change default options for all future instances
		 *
		 * @param {object} d
		 * @return {boolean}
		 */
		setDefaults: function(d) {
			$.extend(defaults, d);
			return true;
		},
		triggerHandler: function() {
			$emitterGlobal.triggerHandler.apply($emitterGlobal, Array.prototype.slice.apply(arguments));
			return this;
		},
		version: function() {
			return semVer;
		}
	};
	
	// $.tooltipster will be used to call global methods
	$.tooltipster = new globalCore();
	
	// the Tooltipster instance class (mind the capital T)
	$.Tooltipster = function(element, options) {
		
		// list of instance variables
		
		// stack of custom callbacks provided as parameters to API methods
		this.callbacks = {
			close: [],
			open: []
		};
		// the schedule time of DOM removal
		this.closingTime;
		// this will be the user content shown in the tooltip. A capital "C" is used
		// because there is also a method called content()
		this.Content;
		// for the size tracker
		this.contentBcr;
		// to disable the tooltip once the destruction has begun
		this.destroyed = false;
		this.destroying = false;
		// we can't emit directly on the instance because if a method with the same
		// name as the event exists, it will be called by jQuery. Se we use a plain
		// object as emitter. This emitter is for internal use by display plugins,
		// if needed.
		this.$emitterPrivate = $({});
		// this emitter is for the user to listen to events without risking to mess
		// with our internal listeners
		this.$emitterPublic = $({});
		this.enabled = true;
		// the reference to the gc interval
		this.garbageCollector;
		// various position and size data recomputed before each repositioning
		this.geometry;
		// proxy the variable for display plugins who may use it
		this.IE = IE;
		this.mouseIsOverOrigin = false;
		// a unique namespace per instance
		this.namespace = 'tooltipster-'+ Math.round(Math.random()*100000);
		this.options;
		// the element to which this tooltip is associated
		this.$origin;
		// will be used to support origins in scrollable areas
		this.$originParents;
		// to remove themes if needed
		this.previousThemes = [];
		// the state can be either : appearing, stable, disappearing, closed
		this.state = 'closed';
		// timeout references
		this.timeouts = {
			close: [],
			open: null
		};
		// this will be the tooltip element (jQuery wrapped HTML element).
		// It's the job of a plugin to create it and append it to the DOM
		this.$tooltip;
		// the reference to the tracker interval
		this.tracker = null;
		// the tooltip left/top coordinates, saved after each repositioning
		this.tooltipCoord;
		
		// launch
		this._init(element, options);
	};
	
	$.Tooltipster.prototype = {
		
		_init: function(element, options) {
			
			var self = this;
			
			self.$origin = $(element);
			self.options = $.extend(true, {}, defaults, options);
			
			// some options may need to be reformatted
			self._optionsFormat();
			
			// note : the content is null (empty) by default and can stay that
			// way if the plugin remains initialized but not fed any content. The
			// tooltip will just not appear.
			
			// let's save the initial value of the title attribute for later
			// restoration if need be.
			var initialTitle = null;
			
			// it will already have been saved in case of multiple tooltips
			if (self.$origin.data('tooltipster-initialTitle') === undefined) {
				
				initialTitle = self.$origin.attr('title');
				
				// we do not want initialTitle to have the value "undefined" because
				// of how jQuery's .data() method works
				if (initialTitle === undefined) initialTitle = null;
				
				self.$origin.data('tooltipster-initialTitle', initialTitle);
			}
			
			// If content is provided in the options, it has precedence over the
			// title attribute.
			// Note : an empty string is considered content, only 'null' represents
			// the absence of content.
			// Also, an existing title="" attribute will result in an empty string
			// content
			if (self.options.content !== null) {
				self._contentSet(self.options.content);
			}
			else {
				self._contentSet(initialTitle);
			}
			
			self.$origin
				// strip the title off of the element to prevent the default tooltips
				// from popping up
				.removeAttr('title')
				// to be able to find all instances on the page later (upon window
				// events in particular)
				.addClass('tooltipstered');
			
			// jQuery < v3.0's addClass and hasClass do not work on SVG elements.
			// However, $('.tooltipstered') does find elements having the class.
			if (!self.$origin.hasClass('tooltipstered')) {
				
				var c = self.$origin.attr('class') || '';
				
				if (c.indexOf('tooltipstered') == -1) {
					self.$origin.attr('class', c +' tooltipstered')
				}
			}
			
			// set listeners on the origin
			self._prepareOrigin();
			
			// set the garbage collector
			self._prepareGC();
			
			// init plugins
			$.each(self.options.plugins, function(i, pluginName) {
				
				var plugin = $.tooltipster.plugin(pluginName);
				
				if (plugin) {
					
					if (plugin.instance) {
						
						var fn = function() {};
						fn.prototype = plugin.instance;
						
						var p = new fn();
						p._init(self);
						
						// proxy public methods on the instance to allow new instance methods
						$.tooltipster._bridge(plugin.instance, p, self, plugin.name);
					}
				}
				else {
					throw new Error('The "'+ pluginName +'" plugin is not defined');
				}
			});
			
			self
				// prepare the tooltip when it gets created. This event must
				// be fired by a plugin
				._on('created', function() {
					self._prepareTooltip();
				})
				// save position information when it's sent by a plugin
				._on('repositioned', function(e) {
					self.tooltipCoord = e.position;
				});
		},
		
		_close: function(event, callback) {
			
			var self = this,
				ok = true;
			
			self._trigger({
				type: 'close',
				event: event,
				stop: function() {
					ok = false;
				}
			});
			
			// a destroying tooltip may not refuse to close
			if (ok || self.destroying) {
				
				// save the method custom callback and cancel any open method custom callbacks
				if (callback) self.callbacks.close.push(callback);
				self.callbacks.open = [];
				
				// clear open/close timeouts
				self._timeoutsClear();
				
				var finishCallbacks = function() {
					
					// trigger any close method custom callbacks and reset them
					$.each(self.callbacks.close, function(i,c) {
						c.call(self, self, {
							event: event,
							origin: self.$origin[0]
						});
					});
					
					self.callbacks.close = [];
				};
				
				if (self.state != 'closed') {
					
					var necessary = true,
						d = new Date(),
						now = d.getTime(),
						newClosingTime = now + self.options.animationDuration[1];
					
					// the tooltip may already already be disappearing, but if a new
					// call to close() is made after the animationDuration was changed
					// to 0 (for example), we ought to actually close it sooner than
					// previously scheduled. In that case it should be noted that the
					// browser will not adapt the animation duration to the new
					// animationDuration that was set after the start of the closing
					// animation.
					// Note: the same thing could be considered at opening, but is not
					// really useful since the tooltip is actually opened immediately
					// upon a call to _openNow(). Since it would not make the opening
					// animation finish sooner, its sole impact would be to trigger the
					// state event and the open callbacks sooner than the actual end of
					// the opening animation, which is not great.
					if (self.state == 'disappearing') {
						
						if (newClosingTime > self.closingTime) {
							necessary = false;
						}
					}
					
					if (necessary) {
						
						self.closingTime = newClosingTime;
						
						if (self.state != 'disappearing') {
							self._stateSet('disappearing');
						}
						
						var finish = function() {
							
							// stop the tracker
							clearInterval(self.tracker);
							
							// a "beforeClose" option has been asked several times but would
							// probably useless since the content element is still accessible
							// via ::content(), and because people can always use listeners
							// inside their content to track what's going on. For the sake of
							// simplicity, this has been denied. Bur for the rare people who
							// really need the option (for old browsers or for the case where
							// detaching the content is actually destructive, for file or
							// password inputs for example), this event will do the work.
							self._trigger({
								type: 'closing',
								event: event
							});
							
							// unbind listeners which are no longer needed
							
							self.$tooltip
								.off('.'+ self.namespace +'-triggerClose')
								.removeClass('tooltipster-dying');
							
							// orientationchange, scroll and resize listeners
							$(window).off('.'+ self.namespace +'-triggerClose');
							
							// scroll listeners
							self.$originParents.each(function(i, el) {
								$(el).off('scroll.'+ self.namespace +'-triggerClose');
							});
							// clear the array to prevent memory leaks
							self.$originParents = null;
							
							$('body').off('.'+ self.namespace +'-triggerClose');
							
							self.$origin.off('.'+ self.namespace +'-triggerClose');
							
							// a plugin that would like to remove the tooltip from the
							// DOM when closed should bind on this
							self._stateSet('closed');
							
							// trigger event
							self._trigger({
								type: 'after',
								event: event
							});
							
							// call our constructor custom callback function
							if (self.options.functionAfter) {
								self.options.functionAfter.call(self, self, {
									event: event,
									origin: self.$origin[0]
								});
							}
							
							// call our method custom callbacks functions
							finishCallbacks();
						};
						
						if (supportsTransitions()) {
							
							self.$tooltip.css({
								'-moz-animation-duration': self.options.animationDuration[1] + 'ms',
								'-ms-animation-duration': self.options.animationDuration[1] + 'ms',
								'-o-animation-duration': self.options.animationDuration[1] + 'ms',
								'-webkit-animation-duration': self.options.animationDuration[1] + 'ms',
								'animation-duration': self.options.animationDuration[1] + 'ms',
								'transition-duration': self.options.animationDuration[1] + 'ms'
							});
							
							self.$tooltip
								// clear both potential open and close tasks
								.clearQueue()
								.removeClass('tooltipster-show')
								// for transitions only
								.addClass('tooltipster-dying');
							
							if (self.options.animationDuration[1] > 0) {
								self.$tooltip.delay(self.options.animationDuration[1]);
							}
							
							self.$tooltip.queue(finish);
						}
						else {
							
							self.$tooltip
								.stop()
								.fadeOut(self.options.animationDuration[1], finish);
						}
					}
				}
				// if the tooltip is already closed, we still need to trigger
				// the method custom callbacks
				else {
					finishCallbacks();
				}
			}
			
			return self;
		},
		
		_contentInsert: function() {
			
			var self = this,
				$el = self.$tooltip.find('.tooltipster-content'),
				formattedContent = self.Content,
				format = function(content) {
					formattedContent = content;
				};
			
			self._trigger({
				type: 'format',
				content: self.Content,
				format: format
			});
			
			if (self.options.functionFormat) {
				
				formattedContent = self.options.functionFormat.call(
					self,
					self,
					{
						origin: self.$origin[0]
					},
					self.Content
				);
			}
			
			if (typeof formattedContent === 'string' && !self.options.contentAsHTML) {
				$el.text(formattedContent);
			}
			else {
				$el
					.empty()
					.append(formattedContent);
			}
		},
		
		_contentSet: function(content) {
			
			// clone if asked. Cloning the object makes sure that each instance has its
			// own version of the content (in case a same object were provided for several
			// instances)
			// reminder : typeof null === object
			if (content instanceof $ && this.options.contentCloning) {
				content = content.clone(true);
			}
			
			this.Content = content;
			
			this._trigger({
				type: 'updated',
				content: content
			});
		},
		
		_destroyError: function() {
			throw new Error('This tooltip has been destroyed and cannot execute your method call.');
		},
		
		/**
		 * Force the browser to redraw (re-render) the tooltip immediately. This is required
		 * when you changed some CSS properties and need to make something with it
		 * immediately, without waiting for the browser to redraw at the end of instructions.
		 * 
		 * @see http://stackoverflow.com/questions/3485365/how-can-i-force-webkit-to-redraw-repaint-to-propagate-style-changes
		 */
		_forceRedraw: function() {
			
			// note : this would work but for Webkit only
			//this.$tooltip.close();
			//this.$tooltip[0].offsetHeight;
			//this.$tooltip.open();
			
			// works in FF too
			var $p = this.$tooltip.parent();
			this.$tooltip.detach();
			this.$tooltip.appendTo($p);
		},
		
		/**
		 * Gather all information about dimensions and available space
		 */
		_geometry: function() {
			
			var	self = this,
				$target = self.$origin,
				originIsArea = self.$origin.is('area');
			
			// if this.$origin is a map area, the target we'll need
			// the dimensions of is actually the image using the map,
			// not the area itself
			if (originIsArea) {
				
				var mapName = self.$origin.parent().attr('name');
				
				$target = $('img[usemap="#'+ mapName +'"]');
			}
			
			var bcr = $target[0].getBoundingClientRect(),
				$document = $(document),
				$window = $(window),
				$parent = $target,
				// some useful properties of important elements
				geo = {
					document: {
						size: {
							height: $document.height(),
							width: $document.width()
						}
					},
					window: {
						scroll: {
							// the second ones are for IE compatibility
							left: window.scrollX || document.documentElement.scrollLeft,
							top: window.scrollY || document.documentElement.scrollTop
						},
						size: {
							height: $window.height(),
							width: $window.width()
						}
					},
					origin: {
						// the origin has a fixed lineage if itself or one of its
						// ancestors has a fixed position
						fixedLineage: false,
						offset: {},
						size: {
							height: bcr.bottom - bcr.top,
							width: bcr.right - bcr.left
						},
						usemapImage: originIsArea ? $target[0] : null,
						windowOffset: {
							left: bcr.left,
							top: bcr.top
						}
					}
				},
				geoFixed = false;
			
			// if the element is a map area, some properties may need
			// to be recalculated
			if (originIsArea) {
				
				var shape = self.$origin.attr('shape'),
					coords = self.$origin.attr('coords');
				
				if (coords) {
					
					coords = coords.split(',');
					
					$.map(coords, function(val, i) {
						coords[i] = parseInt(val);
					});
				}
				
				// if the image itself is the area, nothing more to do
				if (shape != 'default') {
					
					switch(shape) {
						
						case 'circle':
							
							var areaLeft = coords[0],
								areaTop = coords[1],
								areaWidth = coords[2],
								areaTopOffset = areaTop - areaWidth,
								areaLeftOffset = areaLeft - areaWidth;
							
							geo.origin.size.height = areaWidth * 2;
							geo.origin.size.width = geo.origin.size.height;
							
							geo.origin.windowOffset.left += areaLeftOffset;
							geo.origin.windowOffset.top += areaTopOffset;
							
							break;
						
						case 'rect':
							
							var areaLeft = coords[0],
								areaTop = coords[1],
								areaRight = coords[2],
								areaBottom = coords[3],
								areaTopOffset = areaBottom - areaTop,
								areaLeftOffset = areaRight - areaLeft;
							
							geo.origin.size.height = areaBottom - areaTop;
							geo.origin.size.width = areaRight - areaLeft;
							
							geo.origin.windowOffset.left += areaLeftOffset;
							geo.origin.windowOffset.top += areaTopOffset;
							
							break;
						
						case 'poly':
							
							var areaSmallestX = 0,
								areaSmallestY = 0,
								areaGreatestX = 0,
								areaGreatestY = 0,
								arrayAlternate = 'even';
							
							for (var i = 0; i < coords.length; i++) {
								
								var areaNumber = coords[i];
								
								if (arrayAlternate == 'even') {
									
									if (areaNumber > areaGreatestX) {
										
										areaGreatestX = areaNumber;
										
										if (i === 0) {
											areaSmallestX = areaGreatestX;
										}
									}
									
									if (areaNumber < areaSmallestX) {
										areaSmallestX = areaNumber;
									}
									
									arrayAlternate = 'odd';
								}
								else {
									if (areaNumber > areaGreatestY) {
										
										areaGreatestY = areaNumber;
										
										if (i == 1) {
											areaSmallestY = areaGreatestY;
										}
									}
									
									if (areaNumber < areaSmallestY) {
										areaSmallestY = areaNumber;
									}
									
									arrayAlternate = 'even';
								}
							}
							
							geo.origin.size.height = areaGreatestY - areaSmallestY;
							geo.origin.size.width = areaGreatestX - areaSmallestX;
							
							geo.origin.windowOffset.left += areaSmallestX;
							geo.origin.windowOffset.top += areaSmallestY;
							
							break;
					}
				}
			}
			
			// SVG coordinates may need fixing but we need svg.screenbox.js
			// to provide it. SVGElement is IE8+
			if (	window.SVGElement
				&&	$target[0] instanceof SVGElement
				&&	SVG.svgjs
			) {
				
				if (!SVG.parser) {
					SVG.prepare();
				}
				
				var svgEl = SVG.adopt($target[0]);
				
				// not all figures need (and have) screenBBox
				if (svgEl && svgEl.screenBBox) {
					
					var bbox = svgEl.screenBBox();
					
					geo.origin.size.height = bbox.height;
					geo.origin.size.width = bbox.width;
					
					geo.origin.windowOffset.left = bbox.x;
					geo.origin.windowOffset.top = bbox.y;
				}
			}
			
			// user callback through an event
			var edit = function(r) {
				geo.origin.size.height = r.height,
				geo.origin.windowOffset.left = r.left,
				geo.origin.windowOffset.top = r.top,
				geo.origin.size.width = r.width
			};
			
			self._trigger({
				type: 'geometry',
				edit: edit,
				geometry: {
					height: geo.origin.size.height,
					left: geo.origin.windowOffset.left,
					top: geo.origin.windowOffset.top,
					width: geo.origin.size.width
				}
			});
			
			// calculate the remaining properties with what we got
			
			geo.origin.windowOffset.right = geo.origin.windowOffset.left + geo.origin.size.width;
			geo.origin.windowOffset.bottom = geo.origin.windowOffset.top + geo.origin.size.height;
			
			geo.origin.offset.left = geo.origin.windowOffset.left + window.scrollX;
			geo.origin.offset.top = geo.origin.windowOffset.top + window.scrollY;
			geo.origin.offset.bottom = geo.origin.offset.top + geo.origin.size.height;
			geo.origin.offset.right = geo.origin.offset.left + geo.origin.size.width;
			
			// the space that is available to display the tooltip, relatively
			// to the viewport and to the document
			geo.available = {
				window: {
					bottom: {
						height: geo.window.size.height - geo.origin.windowOffset.bottom,
						width: geo.window.size.width
					},
					left: {
						height: geo.window.size.height,
						width: geo.origin.windowOffset.left
					},
					right: {
						height: geo.window.size.height,
						width: geo.window.size.width - geo.origin.windowOffset.right
					},
					top: {
						height: geo.origin.windowOffset.top,
						width: geo.window.size.width
					}
				}
			};
			
			geo.available.document = {
				bottom: {
					height: geo.document.size.height - geo.origin.offset.bottom,
					width: geo.document.size.width
				},
				left: {
					height: geo.document.size.height,
					width: geo.origin.offset.left
				},
				right: {
					height: geo.document.size.height,
					width: geo.document.size.width - geo.origin.offset.right
				},
				top: {
					height: geo.origin.offset.top,
					width: geo.document.size.width
				}
			};
			
			while ($parent[0].tagName.toLowerCase() != 'html') {
				
				if ($parent.css('position') == 'fixed') {
					geo.origin.fixedLineage = true;
					break;
				}
				
				$parent = $parent.parent();
			}
			
			return geo;
		},
		
		/**
		 * For internal use by display plugins, if needed
		 */
		_off: function() {
			this.$emitterPrivate.off.apply(this.$emitterPrivate, Array.prototype.slice.apply(arguments));
			return this;
		},
		
		/**
		 * For internal use by display plugins, if needed
		 */
		_on: function() {
			this.$emitterPrivate.on.apply(this.$emitterPrivate, Array.prototype.slice.apply(arguments));
			return this;
		},
		
		// when using the hover open trigger, this function will schedule the
		// opening of the tooltip after the delay, if there is one
		_open: function(event) {
			
			var self = this,
				ok = true;
			
			if (self.state != 'stable' && self.state != 'appearing') {
				
				self._trigger({
					type: 'start',
					event: event,
					stop: function() {
						ok = false;
					}
				});
				
				if (ok) {
					
					if (self.options.delay[0]) {
						
						self.timeouts.open = setTimeout(function() {
							// open only if the mouse is still over the origin
							if (self.mouseIsOverOrigin) {
								self._openNow(event);
							}
						}, self.options.delay[0]);
					}
					else {
						self._openNow(event);
					}
				}
			}
		},
		
		// this function will open the tooltip right away
		_openNow: function(event, callback) {
			
			var self = this;
			
			// if the destruction process has not begun
			if (!self.destroying) {
				
				// check that the origin is still in the DOM
				if (bodyContains(self.$origin)) {
					
					var ok = true;
					
					// trigger an event. The event.stop function allows the callback
					// to prevent the opening of the tooltip
					self._trigger({
						type: 'before',
						event: event,
						stop: function() {
							ok = false;
						}
					});
					
					if (ok && self.options.functionBefore) {
						
						// call our custom function before continuing
						ok = self.options.functionBefore.call(self, self, {
							event: event,
							origin: self.$origin[0]
						});
					}
					
					if (ok !== false) {
						
						// continue only if the tooltip is enabled and has any content
						if (self.enabled && self.Content !== null) {
							
							// save the method callback and cancel close method callbacks
							if (callback) {
								self.callbacks.open.push(callback);
							}
							self.callbacks.close = [];
							
							// get rid of any appearance timeouts
							self._timeoutsClear();
							
							var extraTime,
								finish = function() {
									
									if (self.state != 'stable') {
										self._stateSet('stable');
									}
									
									// trigger any open method custom callbacks and reset them
									$.each(self.callbacks.open, function(i,c) {
										c.call(self, self, {
											origin: self.$origin[0],
											tooltip: self.$tooltip[0]
										});
									});
									
									self.callbacks.open = [];
								};
							
							// if the tooltip is already open
							if (self.state !== 'closed') {
								
								// the timer (if any) will start (or restart) right now
								extraTime = 0;
								
								// if it was disappearing, cancel that
								if (self.state === 'disappearing') {
									
									self._stateSet('appearing');
									
									if (supportsTransitions()) {
										
										self.$tooltip
											.clearQueue()
											.removeClass('tooltipster-dying')
											.addClass('tooltipster-show');
										
										if (self.options.animationDuration[0] > 0) {
											self.$tooltip.delay(self.options.animationDuration[0]);
										}
										
										self.$tooltip.queue(finish);
									}
									else {
										// in case the tooltip was currently fading out, bring it back
										// to life
										self.$tooltip
											.stop()
											.fadeIn(finish);
									}
								}
								// if the tooltip is already open, we still need to trigger the method
								// custom callback
								else if (self.state == 'stable') {
									finish();
								}
							}
							// if the tooltip isn't already open, open it
							else {
								
								// a plugin must bind on this and make the tooltip available in
								// the DOM (if it isn't yet)
								self._stateSet('appearing');
								
								// the timer (if any) will start when the tooltip has fully appeared
								// after its transition
								extraTime = self.options.animationDuration[0];
								
								self.$tooltip.css({
									// must not overflow the window until the positioning method
									// is called
									height: 0,
									left: 0,
									top: 0,
									overflow: 'hidden',
									width: 0,
									zIndex: self.options.zIndex
								});
								
								// insert the content
								self._contentInsert();
								
								// reposition the tooltip and attach to the DOM
								self.reposition(event, true);
								
								// animate in the tooltip. If the display plugin wants no css
								// animations, it may override the animation option with a
								// dummy value that will produce no effect
								if (supportsTransitions()) {
									
									// note: there seems to be an issue with start animations which
									// are randomly not played on fast devices in both Chrome and FF,
									// couldn't find a way to solve it yet. It seems that applying
									// the classes before appending to the DOM helps a little, but
									// it messes up some CSS transitions. The issue almost never
									// happens when delay[0]==0 though
									self.$tooltip
										.addClass('tooltipster-'+ self.options.animation)
										.addClass('tooltipster-initial');
									
									self.$tooltip.css({
										'-moz-animation-duration': self.options.animationDuration[0] + 'ms',
										'-ms-animation-duration': self.options.animationDuration[0] + 'ms',
										'-o-animation-duration': self.options.animationDuration[0] + 'ms',
										'-webkit-animation-duration': self.options.animationDuration[0] + 'ms',
										'animation-duration': self.options.animationDuration[0] + 'ms',
										'transition-duration': self.options.animationDuration[0] + 'ms'
									});
									
									setTimeout(
										function() {
											
											// a quick hover may have already triggered a mouseleave
											if (self.state != 'closed') {
												
												self.$tooltip
													.addClass('tooltipster-show')
													.removeClass('tooltipster-initial');
												
												if (self.options.animationDuration[0] > 0) {
													self.$tooltip.delay(self.options.animationDuration[0]);
												}
												
												self.$tooltip.queue(finish);
											}
										},
										0
									);
								}
								else {
									
									// old browsers will have to live with this. If the display
									// plugin wants no fading, it will have to cancel it the dirty
									// way, sorry
									self.$tooltip
										.css('display', 'none')
										.fadeIn(self.options.animationDuration[0], finish);
								}
								
								// checks if the origin is removed while the tooltip is open
								self._trackerStart();
								
								// NOTE: the listeners below have a '-triggerClose' namespace
								// because we'll remove them when the tooltip closes (unlike
								// the '-triggerOpen' listeners). So some of them are actually
								// not about close triggers, rather about positioning.
								
								$(window)
									// reposition on resize (in case position can/has to be changed)
									.on('resize.'+ self.namespace +'-triggerClose', function(e) {
										self.reposition(e);
									})
									// same as below for parents
									.on('scroll.'+ self.namespace +'-triggerClose', function(e) {
										self._scrollHandler(e);
									});
								
								self.$originParents = self.$origin.parents();
								
								// scrolling may require the tooltip to be moved or even
								// repositioned in some cases
								self.$originParents.each(function(i, parent) {
									
									$(parent).on('scroll.'+ self.namespace +'-triggerClose', function(e) {
										self._scrollHandler(e);
									});
								});
								
								// here we'll have to set different sets of bindings for both touch
								// and mouse events
								if (self.options.triggerClose.mouseleave) {
									
									// if the user touches the body, close
									if (deviceHasTouchCapability) {
										
										// timeout 0 : to prevent immediate closing if the method was called
										// on a click event and if options.delay == 0 (because of bubbling)
										setTimeout(function() {
											
											if (self.state != 'closed') {
												
												// we don't want to bind on click here because the
												// initial touchstart event has not yet triggered its
												// click event, which is thus about to happen
												$('body').on('touchstart.'+ self.namespace +'-triggerClose', function(event) {
													
													// if the tooltip is not interactive or if the touch was made
													// outside of the tooltip
													if (!self.options.interactive || !$.contains(self.$tooltip[0], event.target)) {
														self._close();
													}
												});
											}
										}, 0);
									}
									
									var $elements = self.$origin,
										timeout = null;
									
									// if we have to allow interaction, bind on the tooltip too
									if (self.options.interactive) {
										$elements = $elements.add(self.$tooltip);
									}
									
									$elements
										// close after some time spent outside of the elements
										.on('mouseleave.'+ self.namespace +'-triggerClose', function(event) {
											
											if (self.options.delay[1]) {
												
												timeout = setTimeout(function() {
													self._close(event);
												}, self.options.delay[1]);
												
												self.timeouts.close.push(timeout);
											}
											else {
												self._close(event);
											}
										})
										// suspend the mouseleave timeout when the mouse comes back
										// over the elements
										.on('mouseenter.'+ self.namespace + '-triggerClose', function() {
											clearTimeout(timeout);
										});
								}
								
								// close the tooltip when the origin gets a click (common behavior of
								// native tooltips)
								if (self.options.triggerClose.originClick) {
									
									self.$origin.on('click.'+ self.namespace + '-triggerClose', function(event) {
										self._close(event);
									});
								}
								
								// here we'll set the same bindings for both clicks and touch on the body
								// to close the tooltip
								if (self.options.triggerClose.click) {
									
									// explanations : same as above
									setTimeout(function() {
										
										if (self.state != 'closed') {
											
											$('body').on('click.'+ self.namespace +'-triggerClose touchstart.'+ self.namespace +'-triggerClose', function(event) {
												if (!self.options.interactive || !$.contains(self.$tooltip[0], event.target)) {
													self._close(event);
												}
											});
										}
									}, 0);
								}
								
								self._trigger('ready');
								
								// call our custom callback
								if (self.options.functionReady) {
									self.options.functionReady.call(self, self, {
										origin: self.$origin[0],
										tooltip: self.$tooltip[0]
									});
								}
							}
							
							// if we have a timer set, let the countdown begin
							if (self.options.timer > 0) {
								
								var timeout = setTimeout(function() {
									self._close();
								}, self.options.timer + extraTime);
								
								self.timeouts.close.push(timeout);
							}
						}
					}
				}
			}
		},
		
		_optionsFormat: function() {
			
			if (typeof this.options.delay == 'number') {
				this.options.delay = [this.options.delay, this.options.delay];
			}
			
			if (typeof this.options.animationDuration == 'number') {
				this.options.animationDuration = [this.options.animationDuration, this.options.animationDuration];
			}
			
			if (typeof this.options.theme == 'string') {
				this.options.theme = [this.options.theme];
			}
			
			// determine the future parent
			if (typeof this.options.parent == 'string') {
				this.options.parent = $(this.options.parent);
			}
			
			if (this.options.trigger == 'hover') {
				
				this.options.triggerOpen = { hover: true };
				
				this.options.triggerClose = {
					mouseleave: true,
					originClick: true
				};
			}
			else if (this.options.trigger == 'click') {
				
				this.options.triggerOpen = { click: true };
				this.options.triggerClose = { click: true };
			}
			
			// for the display plugin
			this._trigger('options');
		},
		
		/**
		 * Sets or cancels the garbage collector interval
		 */
		_prepareGC: function(){
			
			var self = this;
			
			if (self.options.selfDestruction) {
				
				self.garbageCollector = setInterval(function(){
					if(!bodyContains(self.$origin)){
						self.destroy();
					}
				}, 20000);
			}
			else {
				clearInterval(self.garbageCollector);
			}
		},
		
		/**
		 * Set listeners on the origin if the open triggers require them.
		 * Unlike the listeners set at opening time, these ones
		 * remain even when the tooltip is closed. It has been made a
		 * separate method so it can be called when the triggers are
		 * changed in the options.
		 */
		_prepareOrigin: function() {
			
			var self = this;
			
			// in case we're resetting the triggers
			self.$origin.off('.'+ self.namespace +'-triggerOpen');
			
			// for 'click' and 'hover' open triggers : bind on events to open the tooltip.
			// Closing is now handled in _openNow() because of its bindings.
			// Notes about touch events :
			// - mouseenter, mouseleave and clicks happen even on pure touch devices
			//   because they are emulated. deviceIsPureTouch() is a simple attempt
			//   to detect them.
			// - on hybrid devices, we do not prevent touch gesture from opening
			//   tooltips. It would be too complex to differentiate real mouse events
			//   from emulated ones.
			// - we check deviceIsPureTouch() at each event rather than prior to
			//   binding because the situation may change during browsing
			if (self.options.triggerOpen.hover) {
				
				self.$origin.on('mouseenter.'+ self.namespace +'-triggerOpen', function(event) {
					if (!deviceIsPureTouch() || self.options.touchDevices) {
						self.mouseIsOverOrigin = true;
						self._open(event);
					}
				});
				
				// for touch interaction
				if (deviceHasTouchCapability && self.options.touchDevices) {
					
					// for touch devices, we immediately display the tooltip because we
					// cannot rely on mouseleave to handle the delay
					self.$origin.on('touchstart.'+ self.namespace +'-triggerOpen', function(event) {
						self._openNow(event);
					});
				}
			}
			
			if (self.options.triggerOpen.click) {
				
				// note : for touch devices, we do not bind on touchstart, we only rely
				// on the emulated clicks (triggered by taps)
				self.$origin.on('click.'+ self.namespace +'-triggerOpen', function(event) {
					if (!deviceIsPureTouch() || self.options.touchDevices) {
						self._openNow(event);
					}
				});
			}
			
			if (self.options.triggerClose.mouseleave) {
				
				self.$origin.on('mouseleave.'+ self.namespace +'-triggerOpen', function() {
					if (!deviceIsPureTouch() || self.options.touchDevices) {
						self.mouseIsOverOrigin = false;
					}
				});
			}
		},
		
		/**
		 * Do the things that need to be done only once after the tooltip
		 * HTML element it has been created. It has been made a separate
		 * method so it can be called when options are changed. Remember
		 * that the tooltip may actually exist in the DOM before it is
		 * opened, and present after it has been closed: it's the display
		 * plugin that takes care of handling it.
		 */
		_prepareTooltip: function() {
			
			var self = this;
			
			// this will be useful to know quickly if the tooltip is in
			// the DOM or not 
			self.$tooltip.attr('id', self.namespace);
			
			// themes
			// remove the old ones and add the new ones
			$.each(self.previousThemes, function(i, theme) {
				self.$tooltip.removeClass(theme);
			});
			$.each(self.options.theme, function(i, theme) {
				self.$tooltip.addClass(theme);
			});
			
			self.previousThemes = $.merge([], self.options.theme);
			
			// pointer events
			var p = self.options.interactive ? 'auto' : '';
			self.$tooltip.css('pointer-events', p);
		},
		
		/**
		 * Handles the scroll on any of the parents of the origin (when the
		 * tooltip is open)
		 * 
		 * @param {object} event
		 */
		_scrollHandler: function(event) {
			
			var self = this;
			
			if (self.options.triggerClose.scroll) {
				self._close(event);
			}
			else {
				
				// if the scroll happened on the window
				if (event.target === document) {
					
					// if the origin has a fixed lineage, window scroll will have no
					// effect on its position nor on the position of the tooltip
					if (!self.geometry.origin.fixedLineage) {
						
						// we don't need to do anything unless repositionOnScroll is true
						// because the tooltip will already have moved with the window
						// (and of course with the origin)
						if (self.options.repositionOnScroll) {
							self.reposition(event);
						}
					}
				}
				// if the scroll happened on another parent of the tooltip, it means
				// that it's in a scrollable area and now needs to have its position
				// adjusted or recomputed, depending ont the repositionOnScroll
				// option. Also, if the origin is partly hidden due to a parent that
				// hides its overflow, we'll just hide (not close) the tooltip.
				else {
					
					var g = self._geometry(),
						overflows = false;
					
					// a fixed position origin is not affected by the overflow hiding
					// of a parent
					if (self.$origin.css('position') != 'fixed') {
						
						self.$originParents.each(function(i, el) {
							
							var $el = $(el),
								overflowX = $el.css('overflow-x'),
								overflowY = $el.css('overflow-y');
							
							if (overflowX != 'visible' || overflowY != 'visible') {
								
								var bcr = el.getBoundingClientRect();
								
								if (overflowX != 'visible') {
									
									if (	g.origin.windowOffset.left < bcr.left
										||	g.origin.windowOffset.right > bcr.right
									) {
										overflows = true;
										return false;
									}
								}
								
								if (overflowY != 'visible') {
									
									if (	g.origin.windowOffset.top < bcr.top
										||	g.origin.windowOffset.bottom > bcr.bottom
									) {
										overflows = true;
										return false;
									}
								}
							}
							
							// no need to go further if fixed, for the same reason as above
							if ($el.css('position') == 'fixed') {
								return false;
							}
						});
					}
					
					if (overflows) {
						self.$tooltip.css('visibility', 'hidden');
					}
					else {
						self.$tooltip.css('visibility', 'visible');
						
						// reposition
						if (self.options.repositionOnScroll) {
							self.reposition(event);
						}
						// or just adjust offset
						else {
							
							// we have to use offset and not windowOffset because this way,
							// only the scroll distance of the scrollable areas are taken into
							// account (the scrolltop value of the main window must be
							// ignored since the tooltip already moves with it)
							var offsetLeft = g.origin.offset.left - self.geometry.origin.offset.left,
								offsetTop = g.origin.offset.top - self.geometry.origin.offset.top;
							
							// add the offset to the position initially computed by the display plugin
							self.$tooltip.css({
								left: self.tooltipCoord.left + offsetLeft,
								top: self.tooltipCoord.top + offsetTop
							});
						}
					}
				}
				
				self._trigger({
					type: 'scroll',
					event: event
				});
			}
		},
		
		/**
		 * Check if a tooltip can fit in the provided dimensions when we restrain its width.
		 * The idea is to see if the new height is small enough and if the content does not
		 * overflow horizontally.
		 * This method does not reset the position values to what they were when the
		 * test is over, do it yourself if need be.
		 * 
		 * @param {int} width_constr
		 * @param {int} height_constr
		 * @return {object} An object with `height` and `width` properties. Either of these
		 * will be true if the content overflows in that dimension, false if it fits.
		 */
		_sizerConstrained: function(width_constr, height_constr) {
			
			// we'll set a width and see what height is generated and if there
			// is horizontal overflow
			this.$tooltip.css({
				height: '',
				left: 0,
				overflow: 'visible',
				top: 0,
				width: width
			});
			
			this._forceRedraw();
			
			// note: we used to use offsetWidth instead of boundingRectClient but
			// it returned rounded values, causing issues with sub-pixel layouts.
			
			// note2: noticed that the bcrWidth of text content of a div was once
			// greater than the bcrWidth of its container by 1px, causing the final
			// tooltip box to be too small for its content. However, evaluating
			// their widths one against the other (below) surprisingly returned
			// equality. Happened only once in Chrome 48, was not able to reproduce
			// => just having fun with float position values...
			
			var $content = this.$tooltip.find('.tooltipster-content'),
				newHeight = this.$tooltip.outerHeight(),
				tooltipBrc = this.$tooltip[0].getBoundingClientRect(),
				contentBrc = $content[0].getBoundingClientRect(),
				fits = {
					height: newHeight <= height_constr,
					width: (
						// this condition accounts for min-width property that
						// may apply
							tooltipBrc.width <= width_constr
						// the -1 is here because scrollWidth actually returns
						// a rounded value, and may be greater than brc.width if
						// it has been rounded up. This may cause an issue
						// for contents which actually really overflowed
						// by 1px or so, but that should be very rare. Not sure
						// how to solve this efficiently.
						// See http://blogs.msdn.com/b/ie/archive/2012/02/17/sub-pixel-rendering-and-the-css-object-model.aspx
						&&	contentBrc.width >= $content[0].scrollWidth - 1
					)
				},
				width = contentBrc.right;
			
			// old versions of IE get the width wrong for some reason
			if (IE && IE <= 11) {
				width = Math.ceil(width) + 1;
			}
			
			return {
				fits: fits.height && fits.width,
				size: {
					height: newHeight,
					// rounding up fixes an issue in IE11- (at least).
					// Besides, brc.width/height are not defined in IE8- but in this
					// case, brc.right/bottom will have the same value
					width: width
				}
			};
		},
		
		/**
		 * Append the tooltip to its parent after the size tests are over and get rid
		 * of the test container.
		 */
		_sizerEnd: function() {
			
			var $sizer = this.$tooltip.parent();
			
			this.$tooltip
				.appendTo(this.options.parent)
				.find('.tooltipster-content')
					.css('overflow', '');
			
			$sizer.remove();
		},
		
		/**
		 * Get the size of a tooltip when we do not set any specific height or width.
		 * This method does not reset the position values to what they were when the
		 * test is over, do it yourself if need be.
		 * 
		 * Some remarks from ::_sizerConstrained() also apply here
		 */
		_sizerNatural: function() {
			
			// reset to natural size
			this.$tooltip.css({
				height: '',
				left: 0,
				overflow: 'visible',
				top: 0,
				width: ''
			});
			
			this._forceRedraw();
			
			var tooltipBrc = this.$tooltip[0].getBoundingClientRect(),
				width = tooltipBrc.right;
			
			if (IE && IE <= 11) {
				width = Math.ceil(width) + 1;
			}
			
			return {
				height: tooltipBrc.bottom,
				width: width
			};
		},
		
		/**
		 * Move the tooltip into an invisible div that does not allow overflow to make
		 * size tests. Note : the tooltip may or may not be attached to the DOM at the
		 * moment this method is called, it does not matter.
		 */
		_sizerStart: function() {
			
			$('<div class="tooltipster-sizer"></div>')
				.append(this.$tooltip)
				.appendTo('body');
			
			// overflow must be auto during the test
			this.$tooltip.find('.tooltipster-content')
				.css('overflow', 'auto');
		},
		
		/**
		 * Changes the state of the tooltip
		 *
		 * @param {string} state
		 * @return {object} this
		 */
		_stateSet: function(state) {
			
			this.state = state;
			
			this._trigger({
				type: 'state',
				state: state
			});
			
			return this;
		},
		
		/**
		 * Clear appearance timeouts
		 */
		_timeoutsClear: function() {
			
			// there is only one possible open timeout: the delayed opening
			// when the hover open trigger is used
			clearTimeout(this.timeouts.open);
			this.timeouts.open = null;
			
			// ... but several close timeouts: the delayed closing when the
			// mouseleave close trigger is used and the timer option
			$.each(this.timeouts.close, function(i, timeout) {
				clearTimeout(timeout);
			});
			this.timeouts.close = [];
		},
		
		_trackerStart: function() {
			
			var self = this,
				$content = self.$tooltip.find('.tooltipster-content');
			
			// get the initial content size
			if (self.options.trackTooltip) {
				self.contentBcr = $content[0].getBoundingClientRect();
			}
			
			self.tracker = setInterval(function() {
				
				// if the origin or tooltip elements have been removed.
				// Note: we could destroy the instance now if the origin has
				// been removed but we'll leave that task to our garbage collector
				if (!bodyContains(self.$origin) || !bodyContains(self.namespace)) {
					self._close();
				}
				// if everything is alright
				else {
					
					// compare the former and current positions of the origin to reposition
					// the tooltip if need be
					if (self.options.trackOrigin) {
						
						var g = self._geometry(),
							identical = false;
						
						// compare size first (a change requires repositioning too)
						if (areEqual(g.origin.size, self.geometry.origin.size)) {
							
							// for elements that have a fixed lineage (see self::_geometry), we track the
							// top and left properties (relative to window)
							if (self.geometry.origin.fixedLineage) {
								if (areEqual(g.origin.windowOffset, self.geometry.origin.windowOffset)) {
									identical = true;
								}
							}
							// otherwise, track total offset (relative to document)
							else {
								if (areEqual(g.origin.offset, self.geometry.origin.offset)) {
									identical = true;
								}
							}
						}
						
						if (!identical) {
							
							// close the tooltip when using the mouseleave close trigger
							// (see https://github.com/iamceege/tooltipster/pull/253)
							if (self.options.triggerClose.mouseleave) {
								self._close();
							}
							else {
								self.reposition();
							}
						}
					}
					
					if (self.options.trackTooltip) {
						
						var currentBcr = $content[0].getBoundingClientRect();
						
						if (	currentBcr.height !== self.contentBcr.height
							||	currentBcr.width !== self.contentBcr.width
						){
							self.reposition();
							self.contentBcr = currentBcr;
						}
					}
				}
			}, self.options.trackerInterval);
		},
		
		_trigger: function() {
			
			var args = Array.prototype.slice.apply(arguments);
			
			if (typeof args[0] == 'string') {
				args[0] = { type: args[0] };
			}
			
			// add properties to the event
			args[0].instance = this;
			args[0].origin = this.$origin ? this.$origin[0] : null;
			
			// note: the order of emitters matters
			this.$emitterPrivate.trigger.apply(this.$emitterPrivate, args);
			$emitterGlobal.trigger.apply($emitterGlobal, args);
			this.$emitterPublic.trigger.apply(this.$emitterPublic, args);
			
			return this;
		},
		
		_update: function(content) {
			
			var self = this;
			
			// change the content
			self._contentSet(content);
			
			if (self.Content !== null) {
				
				// update the tooltip if it is open
				if (self.state !== 'closed') {
					
					// reset the content in the tooltip
					self._contentInsert();
					
					// reposition and resize the tooltip
					self.reposition();
					
					// if we want to play a little animation showing the content changed
					if (self.options.updateAnimation) {
						
						if (supportsTransitions()) {
							
							// keep the reference in the local scope
							var animation = self.options.updateAnimation;
							
							self.$tooltip.addClass('tooltipster-update-'+ animation);
							
							// remove the class after a while. The actual duration of the
							// update animation may be shorter, it's set in the CSS rules
							setTimeout(function() {
								
								if (self.state != 'closed') {
									
									self.$tooltip.removeClass('tooltipster-update-'+ animation);
								}
							}, 1000);
						}
						else {
							self.$tooltip.fadeTo(200, 0.5, function() {
								if (self.state != 'closed') {
									self.$tooltip.fadeTo(200, 1);
								}
							});
						}
					}
				}
			}
			else {
				self._close();
			}
		},
		
		/**
		 * @see self::_close
		 */
		close: function(callback) {
			
			if (!this.destroyed) {
				this._close(null, callback);
			}
			else {
				this._destroyError();
			}
			
			return this;
		},
		
		content: function(c) {
			
			// getter method
			if (c === undefined) {
				return this.Content;
			}
			// setter method
			else {
				
				if (!this.destroyed) {
					this._update(c);
				}
				else {
					this._destroyError();
				}
				
				return this;
			}
		},
		
		destroy: function() {
			
			var self = this;
			
			if (!self.destroyed) {
				
				if (!self.destroying) {
					
					self.destroying = true;
					
					self._close(null, function() {
						
						self.destroying = false;
						self.destroyed = true;
						
						// last event
						self._trigger('destroyed');
						
						// unbind private and public event listeners
						self._off();
						self.off();
						
						self.$origin
							.removeData(self.namespace)
							// remove the open trigger listeners
							.off('.'+ self.namespace +'-triggerOpen');
						
						var ns = self.$origin.data('tooltipster-ns');
						
						// if the origin has been removed from DOM, its data may
						// well have been destroyed in the process and there would
						// be nothing to clean up or restore
						if (ns) {
							
							// if there are no more tooltips on this element
							if (ns.length === 1) {
								
								// optional restoration of a title attribute
								var title = null;
								if (self.options.restoration === 'previous') {
									title = self.$origin.data('tooltipster-initialTitle');
								}
								else if (self.options.restoration === 'current') {
									
									// old school technique to stringify when outerHTML is not supported
									title = (typeof self.Content === 'string') ?
										self.Content :
										$('<div></div>').append(self.Content).html();
								}
								
								if (title) {
									self.$origin.attr('title', title);
								}
								
								// final cleaning
								
								// normal elements
								if (self.$origin.hasClass('tooltipstered')) {
									self.$origin.removeClass('tooltipstered')
								}
								// SVG elements
								else {
									var c = self.$origin.attr('class').replace('tooltipstered', '');
									self.$origin.attr('class', c);
								}
								
								self.$origin
									.removeData('tooltipster-ns')
									.removeData('tooltipster-initialTitle');
							}
							else {
								// remove the instance namespace from the list of namespaces of
								// tooltips present on the element
								ns = $.grep(ns, function(el, i) {
									return el !== self.namespace;
								});
								self.$origin.data('tooltipster-ns', ns);
							}
						}
						
						// remove external references, just in case
						self.Content = null;
						self.$origin = null;
						self.$emitterPrivate = null;
						self.$emitterPublic = null;
						self.$tooltip = null;
						self.options.parent = null;
						
						// make sure the object is no longer referenced in there to prevent
						// memory leaks
						instancesLatest = $.grep(instancesLatest, function(el, i) {
							return self !== el;
						});
						
						clearInterval(self.garbageCollector);
					});
				}
			}
			else {
				self._destroyError();
			}
			
			// we return the scope rather than true so that the call to
			// .tooltipster('destroy') actually returns the matched elements
			// and applies to all of them
			return self;
		},
		
		disable: function() {
			
			if (!this.destroyed) {
				
				// close first, in case the tooltip would not disappear on
				// its own (no close trigger)
				this._close();
				this.enabled = false;
				
				return this;
			}
			else {
				this._destroyError();
			}
		},
		
		elementOrigin: function() {
			
			if (!this.destroyed) {
				return this.$origin[0];
			}
			else {
				this._destroyError();
			}
		},
		
		elementTooltip: function() {
			return this.$tooltip ? this.$tooltip[0] : null;
		},
		
		enable: function() {
			this.enabled = true;
			return this;
		},
		
		/**
		 * Alias, deprecated in 4.0.0
		 * 
		 * @param callback
		 */
		hide: function(callback) {
			return this.close(callback);
		},
		
		instance: function() {
			return this;
		},
		
		/**
		 * For public use only, not to be used by display plugins (use ::_off() instead)
		 */
		off: function() {
			if (!this.destroyed) {
				this.$emitterPublic.off.apply(this.$emitterPublic, Array.prototype.slice.apply(arguments));
			}
			return this;
		},
		
		/**
		 * For public use only, not to be used by display plugins (use ::_on() instead)
		 */
		on: function() {
			if (!this.destroyed) {
				this.$emitterPublic.on.apply(this.$emitterPublic, Array.prototype.slice.apply(arguments));
			}
			else {
				this._destroyError();
			}
			return this;
		},
		
		/**
		 * For public use only, not to be used by display plugins
		 */
		one: function() {
			if (!this.destroyed) {
				this.$emitterPublic.one.apply(this.$emitterPublic, Array.prototype.slice.apply(arguments));
			}
			else {
				this._destroyError();
			}
			return this;
		},
		
		/**
		 * The public open() method is actually an alias for the private _openNow() method
		 * 
		 * @see self::_openNow
		 */
		open: function(callback) {
			
			if (!this.destroyed && !this.destroying) {
				this._openNow(null, callback);
			}
			else {
				this._destroyError();
			}
			
			return this;
		},
		
		/**
		 * Get or set options. For internal use and advanced users only.
		 * 
		 * @param {string} o Option name
		 * @param {mixed} val optional A new value for the option
		 * @return {mixed} If val is omitted, the value of the option is returned, otherwise
		 * the instance itself is returned
		 */ 
		option: function(o, val) {
			
			// getter
			if (val === undefined) {
				return this.options[o];
			}
			// setter
			else {
				
				if (!this.destroyed) {
					
					// change value
					this.options[o] = val;
					
					// format
					this._optionsFormat();
					
					// re-prepare the triggers if needed
					if ($.inArray(o, ['trigger', 'triggerClose', 'triggerOpen']) >= 0) {
						this._prepareOrigin();
					}
					
					if (o === 'selfDestruction') {
						this._prepareGC();
					}
				}
				else {
					this._destroyError();
				}
				
				return this;
			}
		},
		
		/**
		 * This method is in charge of setting the position and size properties of the tooltip.
		 * All the hard work is delegated to the display plugin.
		 * Note: The tooltip may be detached from the DOM at the moment the method is called 
		 * but must be attached by the end of the method call.
		 * 
		 * @param {object} event For internal use only. Defined if an event such as
		 * window resizing triggered the repositioning
		 * @param {boolean} tooltipIsDetached For internal use only. Set this to true if you
		 * know that the tooltip not being in the DOM is not an issue (typically when the
		 * tooltip element has just been created but has not been added to the DOM yet).
		 */
		reposition: function(event, tooltipIsDetached) {
			
			var self = this;
			
			if (!self.destroyed) {
				
				// if the tooltip has not been removed from DOM manually (or if it
				// has been detached on purpose)
				if (bodyContains(self.namespace) || tooltipIsDetached) {
					
					if (!tooltipIsDetached) {
						// detach in case the tooltip overflows the window and adds
						// scrollbars to it, so _geometry can be accurate
						self.$tooltip.detach();
					}
					
					// refresh the geometry object before passing it as a helper
					self.geometry = self._geometry();
					
					// call the display plugin
					self._trigger({
						type: 'reposition',
						event: event,
						helper: {
							geo: self.geometry
						}
					});
				}
			}
			else {
				self._destroyError();
			}
			
			return self;
		},
		
		/**
		 * Alias, deprecated in 4.0.0
		 *
		 * @param callback
		 */
		show: function(callback) {
			return this.open(callback);
		},
		
		/**
		 * Returns some properties about the instance
		 * 
		 * @returns {object}
		 */
		status: function(){
			
			return {
				destroyed: this.destroyed,
				destroying: this.destroying,
				enabled: this.enabled,
				open: this.state !== 'closed',
				state: this.state
			};
		},
		
		/**
		 * For public use only, not to be used by display plugins
		 */
		triggerHandler: function() {
			if (!this.destroyed) {
				this.$emitterPublic.triggerHandler.apply(this.$emitterPublic, Array.prototype.slice.apply(arguments));
			}
			else {
				this._destroyError();
			}
			return this;
		}
	};
	
	$.fn.tooltipster = function() {
		
		// for using in closures
		var args = Array.prototype.slice.apply(arguments),
			// common mistake : an HTML element can't be in several tooltips at the same time
			contentCloningWarning = 'You are using a single HTML element as content for several tooltips. You probably want to set the contentCloning option to TRUE.';
		
		// this happens with $(sel).tooltipster(...) when $(sel) does not match anything
		if (this.length === 0) {
			
			// still chainable
			return this;
		}
		// this happens when calling $(sel).tooltipster('methodName or options')
		// where $(sel) matches one or more elements
		else {
			
			// method calls
			if (typeof args[0] === 'string') {
				
				var v = '#*$~&';
				
				this.each(function() {
					
					// retrieve the namepaces of the tooltip(s) that exist on that element.
					// We will interact with the first tooltip only.
					var ns = $(this).data('tooltipster-ns'),
						// self represents the instance of the first tooltipster plugin
						// associated to the current HTML object of the loop
						self = ns ? $(this).data(ns[0]) : null;
					
					// if the current element holds a tooltipster instance
					if (self) {
						
						if (typeof self[args[0]] === 'function') {
							
							if (	this.length > 1
								&&	args[0] == 'content'
								&&	typeof args[1] == 'object'
								&&	args[1] !== null
								&&	!self.options.contentCloning
								&&	self.options.debug
							) {
								console.log(contentCloningWarning);
							}
							
							// note : args[1] and args[2] may not be defined
							var resp = self[args[0]](args[1], args[2]);
						}
						else {
							throw new Error('Unknown method "'+ args[0] +'"');
						}
						
						// if the function returned anything other than the instance
						// itself (which implies chaining, except for the `instance` method)
						if (resp !== self || args[0] === 'instance') {
							
							v = resp;
							
							// return false to stop .each iteration on the first element
							// matched by the selector
							return false;
						}
					}
					else {
						throw new Error('You called Tooltipster\'s "'+ args[0] +'" method on an uninitialized element');
					}
				});
				
				return (v !== '#*$~&') ? v : this;
			}
			// first argument is undefined or an object: the tooltip is initializing
			else {
				
				// reset the array of last initialized objects
				instancesLatest = [];
				
				// is there a defined value for the multiple option in the options object ?
				var	multipleIsSet = args[0] && args[0].multiple !== undefined,
					// if the multiple option is set to true, or if it's not defined but
					// set to true in the defaults
					multiple = (multipleIsSet && args[0].multiple) || (!multipleIsSet && defaults.multiple),
					// same for content
					contentIsSet = args[0] && args[0].content !== undefined,
					content = (contentIsSet && args[0].content) || (!contentIsSet && defaults.content),
					// same for contentCloning
					contentCloningIsSet = args[0] && args[0].contentCloning !== undefined,
					contentCloning =
							(contentCloningIsSet && args[0].contentCloning)
						||	(!contentCloningIsSet && defaults.contentCloning),
					// same for debug
					debugIsSet = args[0] && args[0].debug !== undefined,
					debug = (debugIsSet && args[0].debug) || (!debugIsSet && defaults.debug);
				
				if (	this.length > 1
					&&	typeof content == 'object'
					&&	content !== null
					&&	!contentCloning
					&&	debug
				) {
					console.log(contentCloningWarning);
				}
				
				// create a tooltipster instance for each element if it doesn't
				// already have one or if the multiple option is set, and attach the
				// object to it
				this.each(function() {
					
					var go = false,
						$this = $(this),
						ns = $this.data('tooltipster-ns'),
						obj = null;
					
					if (!ns) {
						go = true;
					}
					else if (multiple) {
						go = true;
					}
					else if (debug) {
						console.log('Tooltipster: one or more tooltips are already attached to the element below. Ignoring.');
						console.log(this);
					}
					
					if (go) {
						obj = new $.Tooltipster(this, args[0]);
						
						// save the reference of the new instance
						if (!ns) ns = [];
						ns.push(obj.namespace);
						$this.data('tooltipster-ns', ns);
						
						// save the instance itself
						$this.data(obj.namespace, obj);
						
						// call our constructor custom function.
						// we do this here and not in ::init() because we wanted
						// the object to be saved in $this.data before triggering
						// it
						if (obj.options.functionInit) {
							obj.options.functionInit.call(obj, obj, {
								origin: this
							});
						}
						
						// and now the event, for the global emitter
						obj._trigger('init');
					}
					
					instancesLatest.push(obj);
				});
				
				return this;
			}
		}
	};
	
	// Utilities
	
	// quick & dirty compare function, not bijective nor multidimensional
	function areEqual(a,b) {
		var same = true;
		$.each(a, function(i, _) {
			if (b[i] === undefined || a[i] !== b[i]) {
				same = false;
				return false;
			}
		});
		return same;
	}
	
	/**
	 * A fast function to check if an element is still in the DOM. It
	 * tries to use an id as ids are indexed by the browser, or falls
	 * back to jQuery's `contains` method.
	 *
	 * @param {string|object} ref An id or a jQuery-wrapped HTML element
	 * @return {boolean}
	 */
	function bodyContains(ref) {
		
		var id = (typeof ref === 'string') ? ref : ref.attr('id');
		
		return id ? !!document.getElementById(id) : $.contains(document.body, ref[0]);
	}
	
	// we'll assume the device has no mouse until we detect any mouse movement
	var deviceHasMouse = false;
	$('body').one('mousemove', function() {
		deviceHasMouse = true;
	});
	
	// detect if this device can trigger touch events
	var deviceHasTouchCapability = !!('ontouchstart' in window);
	
	function deviceIsPureTouch() {
		return (!deviceHasMouse && deviceHasTouchCapability);
	}
	
	// detect IE versions for dirty fixes
	var uA = navigator.userAgent.toLowerCase(),
		IE = false;
	
	if (uA.indexOf('msie') != -1) IE = parseInt(uA.split('msie')[1]);
	else if (uA.toLowerCase().indexOf('trident') !== -1 && uA.indexOf(' rv:11') !== -1) IE = 11;
	else if (uA.toLowerCase().indexOf('edge/') != -1) IE = parseInt(uA.toLowerCase().split('edge/')[1]);
	
	// detecting support for CSS transitions
	function supportsTransitions() {
		var b = document.body || document.documentElement,
			s = b.style,
			p = 'transition',
			v = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];
		
		if (typeof s[p] == 'string') { return true; }
		
		p = p.charAt(0).toUpperCase() + p.substr(1);
		for (var i=0; i<v.length; i++) {
			if (typeof s[v[i] + p] == 'string') { return true; }
		}
		return false;
	}
})(jQuery);


/**
 * The default plugin
 */
(function($) {
	
	$.tooltipster.plugin({
		name: 'ttr.sideTip',
		instance: {
			/**
			 * Defaults are provided as a function for an easy override by inheritance
			 *
			 * @return {object} An object with the defaults options
			 */
			_defaults: function() {
				
				return {
					// if the tooltip should display an arrow that points to the origin
					arrow: true,
					// the distance in pixels between the tooltip and the origin
					distance: 6,
					// allows to easily change the position of the tooltip
					functionPosition: null,
					maxWidth: null,
					minWidth: 0,
					side: ['top', 'bottom', 'right', 'left']
					/*
					// TODO: these rules let the user choose what to do when the tooltip content
					// overflows. Right now the order of fallbacks is fixed :
					// - we're looking for a spot where the natural size of the tooltip can fit
					//   ('window.switch')
					// - if can't find one, we check if setting a constrained width on the
					//   tooltip could solve the problem without having the content overflowing
					//   ('window.constrain')
					// - if it does not work, we let the tooltip overflow the window in its
					//   natural size, in the limits of the document ('document.switch')
					// - if it does not work, we see if a constrained width could make the
					//   tooltip fit in the document without its content overflowing
					//   ('document.constrain')
					// - and if that can't be done, we just let the tooltip on the preferred
					//   side with a natural size, overflowing the document
					//   ('document.overflow')
					positioningRules: [
						'window.switch',
						// or try to see if the tooltip could be displayed somewhere with a
						// constrained width without its content overflowing
						'window.constrain',
						// TODO : window.scroll should be a possible rule, rather than fall
						// back to overflowing in the rest of the document. The content would
						// have horizontal and/or vertical scrollbars but the tooltip would not
						// overflow the window. It would require to set a max-height on the
						// content div, etc.
						//'window.scroll',
						'document.switch',
						'document.constrain',
						// TODO - similar to 'window.scroll'
						//'document.scroll'
						'document.overflow'
					]
					*/
				};
			},
			
			/**
			 * Run once: at instantiation of the plugin
			 *
			 * @param {object} instance The tooltipster object that instantiated
			 * this plugin
			 */
			_init: function(instance) {
				
				var self = this;
				
				// list of instance variables
				
				self.instance = instance;
				self.options;
				self.previousState = 'closed';
				
				// initial formatting
				self._optionsFormat();
				
				self.instance._on('state', function(event) {
					
					if (event.state == 'closed') {
						self._close();
					}
					else if (event.state == 'appearing' && self.previousState == 'closed') {
						self._create();
					}
					
					self.previousState = event.state;
				});
				
				// reformat every time the options are changed
				self.instance._on('options', function() {
					self._optionsFormat();
				});
				
				self.instance._on('reposition', function(e) {
					self._reposition(e.event, e.helper);
				});
			},
			
			_close: function() {
				
				// detach our content object first, so the next jQuery's remove()
				// call does not unbind its event handlers
				if (typeof this.instance.Content == 'object' && this.instance.Content !== null) {
					this.instance.Content.detach();
				}
				
				// remove the tooltip from the DOM
				this.instance.$tooltip.remove();
			},
			
			/**
			 * Contains the HTML markup of the tooltip.
			 *
			 * @return {object} The tooltip, as a jQuery-wrapped HTML element
			 */
			_create: function() {
				
				// note: we wrap with a .tooltipster-box div to be able to set a margin on it
				// (.tooltipster-base must not have one)
				var $html = $(
					'<div class="tooltipster-base">' +
					'<div class="tooltipster-box">' +
					'<div class="tooltipster-content"></div>' +
					'</div>' +
					'<div class="tooltipster-arrow">' +
					'<div class="tooltipster-arrow-uncropped">' +
					'<div class="tooltipster-arrow-border"></div>' +
					'<div class="tooltipster-arrow-background"></div>' +
					'</div>' +
					'</div>' +
					'</div>'
				);
				
				// hide arrow if asked
				if (!this.options.arrow) {
					$html
						.find('.tooltipster-box')
						.css('margin', 0)
						.end()
						.find('.tooltipster-arrow')
						.hide();
				}
				
				// apply min/max width if asked
				if (this.options.minWidth) {
					$html.css('min-width', this.options.minWidth + 'px');
				}
				if (this.options.maxWidth) {
					$html.css('max-width', this.options.maxWidth + 'px');
				}
				
				this.instance.$tooltip = $html;
				
				this.instance.$tooltip.appendTo(this.options.parent);
				
				// tell the instance that the tooltip element has been created
				this.instance._trigger('created');
			},
			
			/**
			 * (Re)compute this.options from the options declared to the instance
			 */
			_optionsFormat: function() {
				
				var defaults = this._defaults();
				
				this.options = $.extend(true, {}, defaults, this.instance.options);
				
				// for backward compatibility, deprecated in v4.0.0
				if (this.options.position) {
					this.options.side = this.options.position;
				}
				// $.extend merges arrays, we don't want that, we only want the
				// array provided by the user
				if (typeof this.instance.options.side == 'object') {
					this.options.side = this.instance.options.side;
				}
				
				// options formatting
				
				// format distance as a four-cell array if it ain't one yet and then make
				// it an object with top/bottom/left/right properties
				if (typeof this.options.distance != 'object') {
					this.options.distance = [this.options.distance];
				}
				if (this.options.distance.length < 4) {
					
					if (this.options.distance[1] === undefined) this.options.distance[1] = this.options.distance[0];
					if (this.options.distance[2] === undefined) this.options.distance[2] = this.options.distance[0];
					if (this.options.distance[3] === undefined) this.options.distance[3] = this.options.distance[1];
					
					this.options.distance = {
						top: this.options.distance[0],
						right: this.options.distance[1],
						bottom: this.options.distance[2],
						left: this.options.distance[3]
					};
				}
				
				// let's transform 'top' into ['top', 'bottom', 'right', 'left'] (for example)
				if (typeof this.options.side == 'string') {
					
					this.options.side = [this.options.side];
					
					for (var i=0; i<4; i++) {
						if (this.options.side[0] != defaults.side[i]) {
							this.options.side.push(defaults.side[i]);
						}
					}
				}
				
				// misc
				
				// disable the arrow in IE6 unless the arrow option was explicitly set to true
				if (	this.instance.IE === 6
					&&	this.options.arrow !== true
				) {
					this.options.arrow = false;
				}
			},
			
			/**
			 * This method must compute and set the positioning properties of the
			 * tooltip (left, top, width, height, etc.). It must also make sure the
			 * tooltip is eventually appended to its parent (since the element may be
			 * detached from the DOM at the moment the method is called).
			 *
			 * Plugin creators will at least have to use self.instance.$tooltip.
			 * Also, some of its methods may help plugin
			 * creators, especially its _sizer utilities that help measure the size
			 * of the tooltip in various conditions.
			 *
			 * @param {object} helper An object that contains variables that plugin
			 * creators may find useful (see below)
			 * @param {object} helper.geo An object with many layout properties
			 * about objects of interest (window, document, origin). This should help
			 * plugin users compute the optimal position of the tooltip
			 */
			_reposition: function(event, helper) {
				
				var self = this,
					finalResult,
					testResults = {
						document: {},
						window: {}
					};
				
				// start position tests session
				self.instance._sizerStart();
				
				// find which side can contain the tooltip without overflow.
				// We'll compute things relatively to window, then document if need be.
				$.each(['window', 'document'], function(i, container) {
					
					var fits,
						constrainedFits = false,
						distance,
						naturalSize,
						outerNaturalSize,
						side,
						sizerResult;
					
					for (var i=0; i < self.options.side.length; i++) {
						
						distance = {
							horizontal: 0,
							vertical: 0
						};
						side = self.options.side[i];
						
						// this may have an effect on the size of the tooltip if there are css
						// rules for the arrow or something else
						self._sideChange(side);
						
						// now we get the size of the tooltip when it does not have any size
						// constraints set
						naturalSize = self.instance._sizerNatural();
						
						if (side == 'top' || side == 'bottom') {
							distance.vertical = self.options.distance[side];
						}
						else {
							distance.horizontal = self.options.distance[side];
						}
						
						outerNaturalSize = {
							height: naturalSize.height + distance.vertical,
							width: naturalSize.width + distance.horizontal
						};
						
						testResults[container][side] = {};
						
						// if the tooltip can fit without any adjustment
						fits = false;
						
						if (	helper.geo.available[container][side].width >= outerNaturalSize.width
							&&	helper.geo.available[container][side].height >= outerNaturalSize.height
						) {
							fits = true;
						}
						
						testResults[container][side].natural = {
							fits: fits,
							distance: distance,
							outerSize: outerNaturalSize,
							side: side,
							size: naturalSize,
							sizeMode: 'natural'
						};
						
						if (fits) {
							
							// we don't need to compute more positions, a natural one is fine
							return false;
						}
						else {
							
							// let's try to use size constraints to fit
							sizerResult = self.instance._sizerConstrained(
								helper.geo.available[container][side].width - distance.horizontal,
								helper.geo.available[container][side].height - distance.vertical
							);
							
							testResults[container][side].constrained = {
								fits: sizerResult.fits,
								distance: distance,
								outerSize: {
									height: sizerResult.size.height + distance.vertical,
									width: sizerResult.size.width + distance.horizontal
								},
								side: side,
								size: sizerResult.size,
								sizeMode: 'constrained'
							};
							
							if (sizerResult.fits) {
								// we let tests run as we may find a fitting natural size
								// on the next sides
								constrainedFits = true;
							}
						}
					}
					
					// if a constrained size fits, don't run tests against the document
					if (constrainedFits) {
						return false;
					}
				});
				
				
				// Based on tests, pick the side we'll use.
				// TODO : let the user choose the order of the positioning rules
				$.each(['window', 'document'], function(i, container) {
					for (var i=0; i < self.options.side.length; i++) {
						
						var side = self.options.side[i];
						
						$.each(['natural', 'constrained'], function(i, mode) {
							
							if (	testResults[container][side][mode]
								&&	testResults[container][side][mode].fits
							) {
								finalResult = testResults[container][side][mode];
								finalResult.container = container;
								return false;
							}
						});
						
						if (finalResult) {
							return false;
						}
					}
				});
				// if everything failed, this falls back on the preferred side but the
				// tooltip will overflow the document
				if (!finalResult) {
					finalResult = testResults.document[self.options.side[0]].natural;
					finalResult.container = 'overflow';
				}
				
				// first, let's find the coordinates of the tooltip relatively to the
				// window.
				finalResult.coord = {};
				
				// to know where to put the tooltip, we need to know on which point
				// of the x or y axis we should center it. That coordinate is the target
				finalResult.target = self._targetFind(helper, finalResult.side);
				
				switch (finalResult.side) {
					
					case 'left':
					case 'right':
						finalResult.coord.top = Math.floor(finalResult.target - finalResult.size.height / 2);
						break;
					
					case 'bottom':
					case 'top':
						finalResult.coord.left = Math.floor(finalResult.target - finalResult.size.width / 2);
						break;
				}
				
				switch (finalResult.side) {
					
					case 'left':
						finalResult.coord.left = helper.geo.origin.windowOffset.left - finalResult.outerSize.width;
						break;
					
					case 'right':
						finalResult.coord.left = helper.geo.origin.windowOffset.left + helper.geo.origin.size.width + finalResult.distance.horizontal;
						break;
					
					case 'top':
						finalResult.coord.top = helper.geo.origin.windowOffset.top - finalResult.outerSize.height;
						break;
					
					case 'bottom':
						finalResult.coord.top = helper.geo.origin.windowOffset.top + helper.geo.origin.size.height + finalResult.distance.vertical;
						break;
				}
				
				// then if the tooltip overflows the viewport, we'll move it accordingly (it will
				// not be centered on the middle of the origin anymore). We only move horizontally
				// for top and bottom tooltips and vice versa.
				if (finalResult.side == 'top' || finalResult.side == 'bottom') {
					
					// if there is an overflow on the left
					if (finalResult.coord.left < 0) {
						finalResult.coord.left = 0;
					}
					// or an overflow on the right
					else if (finalResult.coord.left + finalResult.size.width > helper.geo.window.size.width) {
						finalResult.coord.left += helper.geo.window.size.width - (finalResult.coord.left + finalResult.size.width);
					}
				}
				else {
					
					// overflow on top
					if (finalResult.coord.top < 0) {
						finalResult.coord.top = 0;
					}
					// or at bottom
					else if (finalResult.coord.top + finalResult.size.height > helper.geo.window.size.height) {
						finalResult.coord.top += helper.geo.window.size.height - (finalResult.coord.top + finalResult.size.height);
					}
				}
				
				// this will be used so that the final arrow target is not too close
				// from the edge of the tooltip so that the arrow does not overflow
				// the tooltip. It should be equal or greater than half the width of
				// the arrow (by width we mean the size of the side which touches the
				// side of the tooltip). 
				finalResult.arrowMargin = 10;
				
				
				// submit the positioning proposal to the user function which may choose to change
				// the side, size and/or the coordinates
				
				// first, set the rules that corresponds to the proposed side: it may change
				// the size of the tooltip, and the custom functionPosition may want to detect the
				// size of something before making a decision. So let's make things easier for the
				// implementor
				self._sideChange(finalResult.side);
				
				// now unneeded, we don't want it passed to functionPosition
				delete finalResult.fits;
				delete finalResult.outerSize;
				
				// simplify this for the functionPosition callback
				finalResult.distance = finalResult.distance.horizontal || finalResult.distance.vertical;
				
				// allow the user to easily prevent its content from overflowing
				// if he constrains the size of the tooltip
				finalResult.contentOverflow = 'initial';
				
				// add some variables to the helper for the custom function
				helper.origin = self.instance.$origin[0];
				helper.tooltip = self.instance.$tooltip[0];
				helper.tooltipParent = self.options.parent[0];
				
				var edit = function(result) {
					finalResult = result;
				};
				
				// emit event on the instance
				self.instance._trigger({
					type: 'position',
					edit: edit,
					position: finalResult
				});
				
				if (self.options.functionPosition) {
					
					var r = self.options.functionPosition.call(self, self.instance, helper, $.extend(true, {}, finalResult));
					
					if (r) finalResult = r;
				}
				
				
				// compute the position of the target relatively to the
				// tooltip container so we can place the arrow, and make needed
				// adjustments
				var arrowCoord,
					maxVal;
				
				if (finalResult.side == 'top' || finalResult.side == 'bottom') {
					
					arrowCoord = {
						prop: 'left',
						val: finalResult.target - finalResult.coord.left
					};
					maxVal = finalResult.size.width - finalResult.arrowMargin;
				}
				else {
					
					arrowCoord = {
						prop: 'top',
						val: finalResult.target - finalResult.coord.top
					};
					maxVal = finalResult.size.height - finalResult.arrowMargin;
				}
				
				// cannot lie beyond the boundaries of the tooltip, minus the
				// arrow margin
				if (arrowCoord.val < finalResult.arrowMargin) {
					arrowCoord.val = finalResult.arrowMargin;
				}
				else if (arrowCoord.val > maxVal) {
					arrowCoord.val = maxVal;
				}
				
				var originParentOffset;
				
				// let's convert the window-relative coordinates into coordinates relative to the
				// future positioned parent that the tooltip will be appended to
				if (helper.geo.origin.fixedLineage) {
					
					// same as windowOffset when the position is fixed
					originParentOffset = helper.geo.origin.windowOffset;
				}
				else {
					
					// this assumes that the parent of the tooltip is located at
					// (0, 0) in the document, typically like when the parent is
					// <body>.
					// If we ever allow other types of parent, .tooltipster-sizer
					// will have to be appended to the parent to inherit css style
					// values that affect the display of the text and such.
					originParentOffset = {
						left: helper.geo.origin.windowOffset.left + helper.geo.window.scroll.left,
						top: helper.geo.origin.windowOffset.top + helper.geo.window.scroll.top
					};
				}
				
				finalResult.coord = {
					left: originParentOffset.left + (finalResult.coord.left - helper.geo.origin.windowOffset.left),
					top: originParentOffset.top + (finalResult.coord.top - helper.geo.origin.windowOffset.top)
				};
				
				// set position values
				
				// again, in case functionPosition changed the side
				self._sideChange(finalResult.side);
				
				if (helper.geo.origin.fixedLineage) {
					self.instance.$tooltip
						.css('position', 'fixed');
				}
				else {
					// CSS default
					self.instance.$tooltip
						.css('position', '');
				}
				
				self.instance.$tooltip
					.css({
						left: finalResult.coord.left,
						top: finalResult.coord.top
					})
					.find('.tooltipster-box')
					.css('overflow', finalResult.contentOverflow)
					.end()
					.find('.tooltipster-arrow')
					.css({
						'left': '',
						'top': ''
					})
					.css(arrowCoord.prop, arrowCoord.val);
				
				// we need to set a size even if the tooltip is in its natural size
				// because when the tooltip is positioned beyond the width of the body
				// (which is by default the width of the window; it will happen when
				// you scroll the window horizontally to get to the origin), its text
				// content will otherwise break lines at each word to keep up with the
				// body overflow strategy.
				self.instance.$tooltip
					.css({
						height: finalResult.size.height,
						width: finalResult.size.width
					});
				
				// end positioning tests session and append the tooltip HTML element
				// to its parent
				self.instance._sizerEnd();
				
				self.instance._trigger({
					type: 'repositioned',
					event: event,
					position: finalResult
				});
			},
			
			/**
			 * Make whatever modifications are needed when the side is changed. This has
			 * been made an independant method for easy inheritance in custom plugins based
			 * on this default plugin.
			 *
			 * @param {string} side
			 */
			_sideChange: function(side) {
				
				this.instance.$tooltip
					.removeClass('tooltipster-bottom')
					.removeClass('tooltipster-left')
					.removeClass('tooltipster-right')
					.removeClass('tooltipster-top')
					.addClass('tooltipster-'+ side);
			},
			
			/**
			 * Returns the target that the tooltip should aim at for a given side.
			 * The calculated value is a distance from the edge of the window
			 * (left edge for top/bottom sides, top edge for left/right side). The
			 * tooltip will be centered on that position and the arrow will be
			 * positioned there (as much as possible).
			 *
			 * @param {string} side
			 * @return {integer}
			 */
			_targetFind: function(helper, side) {
				
				var target,
					rects = this.instance.$origin[0].getClientRects();
				
				// by default, the target will be the middle of the origin
				if (rects.length < 2) {
					
					switch (side) {
						
						case 'left':
						case 'right':
							target = Math.floor(helper.geo.origin.windowOffset.top + (helper.geo.origin.size.height / 2));
							break;
						
						case 'bottom':
						case 'top':
							target = Math.floor(helper.geo.origin.windowOffset.left + (helper.geo.origin.size.width / 2));
							break;
					}
				}
				// if multiple client rects exist, the element may be text split
				// up into multiple lines and the middle of the origin may not be
				// best option anymore
				else {
					
					var targetRect;
					
					// choose the best target client rect
					switch (side) {
						
						case 'top':
							
							// first
							targetRect = rects[0];
							break;
						
						case 'right':
							
							// the middle line, rounded down in case there is an even
							// number of lines (looks more centered => check out the
							// demo with 4 split lines)
							if (rects.length > 2) {
								targetRect = rects[Math.ceil(rects.length / 2) - 1];
							}
							else {
								targetRect = rects[0];
							}
							break;
						
						case 'bottom':
							
							// last
							targetRect = rects[rects.length - 1];
							break;
						
						case 'left':
							
							// the middle line, rounded up
							if (rects.length > 2) {
								targetRect = rects[Math.ceil((rects.length + 1) / 2) - 1];
							}
							else {
								targetRect = rects[rects.length - 1];
							}
							break;
					}
					
					switch (side) {
						
						case 'left':
						case 'right':
							target = Math.floor(targetRect.top + (targetRect.bottom - targetRect.top) / 2);
							
							break;
						
						case 'bottom':
						case 'top':
							target = Math.floor(targetRect.left + (targetRect.right - targetRect.left) / 2);
							break;
					}
				}
				
				return target;
			}
		}
	});
	
})(jQuery);